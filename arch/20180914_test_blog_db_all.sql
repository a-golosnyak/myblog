-- phpMyAdmin SQL Dump
-- version 4.7.7
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1:3306
-- Время создания: Сен 14 2018 г., 17:55
-- Версия сервера: 5.6.38
-- Версия PHP: 5.5.38

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `test_blog_db`
--

-- --------------------------------------------------------

--
-- Структура таблицы `category`
--

CREATE TABLE `category` (
  `id` int(10) UNSIGNED NOT NULL,
  `category_name` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `category`
--

INSERT INTO `category` (`id`, `category_name`) VALUES
(1, 'Микроконтроллеры STM32'),
(2, 'Программирование Linux'),
(3, 'Электроника'),
(4, 'ЧПУ'),
(5, 'Разное');

-- --------------------------------------------------------

--
-- Структура таблицы `posts`
--

CREATE TABLE `posts` (
  `id` int(10) UNSIGNED NOT NULL,
  `author_id` int(10) UNSIGNED DEFAULT NULL,
  `category_id` int(10) UNSIGNED DEFAULT NULL,
  `pub_date` datetime DEFAULT NULL,
  `title` varchar(220) DEFAULT NULL,
  `art_intro` varchar(800) DEFAULT NULL,
  `art_intro_img` varchar(255) DEFAULT NULL,
  `post_body` text
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `posts`
--

INSERT INTO `posts` (`id`, `author_id`, `category_id`, `pub_date`, `title`, `art_intro`, `art_intro_img`, `post_body`) VALUES
(50, 7, 1, '2018-09-12 11:36:16', 'Недорогой аудио фильтр подавляет шумы и фон', 'Описанный в этой статье недорогой многозвенный пассивный фильтр не нуждается в источнике питания и может улучшить характеристики аудио и измерительного оборудования, ослабляя сетевой фон и уровень паразитных сигналов вещательных станций АМ, FM и нижней части VHF диапазонов (Рисунок 1). Композитный фильтр образован каскадным соединением трех простых фильтров: Т-образного фильтра верхних частот для ослабления фона источника питания и двух П-образных фильтров нижних частот для подавления паразитных радиочастотных сигналов. В варианте, показанном на схеме, эти три секции образуют не имеющий потерь фильтр Чебышева с пульсациями 0.01 дБ на нагрузке с входным импедансом 50 Ом, но при необходимости вы можете пересчитать параметры компонентов фильтра под другой импеданс.', 'images/posts/2018-09-12_113616_Nedor_723.jpeg', 'Перечень компонентов, использованных в прототипе фильтра, приведен в Таблице 1. За исключением индуктивности L3, все компоненты общедоступны и имеют стандартные значения номиналов. Переключатель S1&amp;nbsp;предназначен для обхода фильтра и позволяет ускорить измерения, исключив необходимость соединения и отключения от макета разъемов BNC. Чтобы собрать прототип, соедините все компоненты на куске беспаечной макетной платы, который поместите между металлическими разделителями (Рисунок 2) внутри литого алюминиевого корпуса. Этот метод экранирования конструкции ранее доказал свою эффективность в другом лабораторном эксперименте [1]. Результаты измерений потерь, вносимых фильтром в диапазоне частот от 40 Гц до 200 МГц, отражены в Таблице 2.\r\n\r\n\r\n	\r\n		\r\n			Таблица 2.\r\n			Потери, вносимые фильтром\r\n		\r\n		\r\n			\r\n			\r\n				\r\n					\r\n						Частота\r\n						(кГц)\r\n						Вносимые\r\n						потери\r\n						(дБ)\r\n						Частота\r\n						(МГц)\r\n						Вносимые\r\n						потери\r\n						(дБ)\r\n					\r\n					\r\n						0.04\r\n						45.2\r\n						0.1\r\n						42.3\r\n					\r\n					\r\n						0.07\r\n						35.4\r\n						0.3\r\n						60\r\n					\r\n					\r\n						0.1\r\n						29.4\r\n						0.5\r\n						60\r\n					\r\n					\r\n						0.2\r\n						17.3\r\n						1\r\n						55.5\r\n					\r\n					\r\n						0.3\r\n						10.9\r\n						2\r\n						52.2\r\n					\r\n					\r\n						0.5\r\n						5.5\r\n						3\r\n						51.1\r\n					\r\n					\r\n						1\r\n						2.7\r\n						4\r\n						56.2\r\n					\r\n					\r\n						2\r\n						2\r\n						5\r\n						60\r\n					\r\n					\r\n						5\r\n						1.9\r\n						10\r\n						46.5\r\n					\r\n					\r\n						10\r\n						2.1\r\n						25\r\n						44\r\n					\r\n					\r\n						15\r\n						2.7\r\n						50\r\n						40.5\r\n					\r\n					\r\n						20\r\n						4.5\r\n						100\r\n						39.5\r\n					\r\n					\r\n						30\r\n						11.7\r\n						150\r\n						45\r\n					\r\n					\r\n						50\r\n						24.5\r\n						200\r\n						44\r\n					\r\n				\r\n			\r\n			\r\n		\r\n	\r\n\r\n\r\nИспользование в качестве C1&amp;nbsp;&amp;hellip; C6&amp;nbsp;дешевых полярных электролитических конденсаторов позволяет получить вполне приемлемые характеристики схемы, но требует соблюдения полярности постоянной составляющей входного сигнала. Немного увеличив стоимость и время монтажа, вы можете улучшить характеристики и воспроизводимость параметров фильтров, отобрав эти конденсаторы по величине емкости, чтобы ее отклонения не превышали 10%. Для достижения наилучших результатов используйте неполярные конденсаторы C1&amp;nbsp;&amp;hellip; C6. Для некритичных приложений вы можете ослабить допуски остальных конденсаторов и использовать индуктивности L1, L2&amp;nbsp;и L3&amp;nbsp;со стандартными номиналами 22 мГн, 0.68 мГн и 3.9 мкГн, соответственно.\r\n'),
(53, 1, 1, '2018-09-13 10:02:16', 'STM32 и FreeRTOS. Развлечение с потоками.', 'Очень часто (да что там часто, практически всегда) микроконтроллеры применяют в условиях, когда необходимо отслеживать сразу несколько параметров. Или наоборот, управлять одновременно несколькими устройствами.\n\nВот задача для примера: у нас есть 4 выхода, на которых необходимо выводить импульсы разной длительности с разными паузами. Все, что у нас есть &ndash; это системный таймер, который считает в миллисекундах.', 'images/posts/2018-09-13_100216_STM32_658.jpeg', 'Усложняем задачу в духе &amp;ldquo;сам себя замучаю на ардуино&amp;rdquo;. Таймеры заняты другим, PWM не подходит, ибо не на всех ножках он работает, да и не загонишь его на нужные режимы обычно. Немного подумав, садимся и пишем примерно такой код\n&amp;nbsp;\n\n\n// инициализация\nint time1on=500; // Время, пока выход 1 должен быть включен\nint time1off=250; // Время, пока выход 1 должен быть выключен\nunsigned int now=millis();\n....\n// где-то в цикле\nif(millis()&amp;lt;now+time1on)\n{\n  port1=ON;\n}\nelse\n{\nport1=OFF;\nif(millis()&amp;gt;now+time1on+time1off)\n  {\n  now=millis();\n  }\n}\n\n\n\n\nИ так или примерно так для всех 4 портов. Получается приличная портянка на несколько экранов, но эта портянка работает и работает довольно быстро, что для микроконтроллера важно.\n\nПотом внезапно программист замечает, что при каждом цикле дергается порт, даже если его состояние не меняется. Правит всю портянку. Потом число портов с такими же потребностями увеличивается в два раза. Программист плюет и переписывает все в одну функцию типа PortBlink(int port num).\n\nПочти наступило счастье, но внезапно потребовалось что бы на каком-то порту вместе с управлением &amp;ldquo;на выход&amp;rdquo; что-то предварительно считывалось и уже на основе этого считанного управлялся порт. Программист снова матерится и делает еще одну функцию, специально под порт.\n\nСчастье? А вот фигу. Заказчик что-то этакое прицепил и это считанное может легко тормознуть процесс на секунды &amp;hellip; Начинается стенания, программисты правят в очередной раз код, окончательно превращая его в нечитаемый треш, менеджеры выкатывают дикие прайсы заказчику за добавление функционала, заказчик матерится и решает больше никогда не связываться со встроенными решениями.\n\n(типа реклама и восхваление) А все почему? Потому что изначально было принято неправильное решение о платформе. Если есть возможность, мы предлагаем навороченную платформу даже для примитивных задач. По опыту стоимость разработки и поддержки потом оказываются гораздо ниже. Вот и сейчас для управления 8мю выходами я возьму STM32F3, который может работать на 72МГц. (шепотом) На самом деле просто у меня под рукой демоплата с ним (смаил). Была еще с L1, но мы ее нечаянно использовали в одном из проектов.\n\nОткрываем STM32Cube, выбираем плату, включаем галочку около FreeRTOS и собираем проект как обычно. Нам ничего этакого не надо, поэтому оставляем все по умолчанию.\n\nЧто такое FreeRTOS? Это операционная система почти реального времени для микроконтроллеров. То есть все, что вы слышали про операционные системы типа многозадачности, семафоров и прочих мутексов. Почему FreeRTOS? Просто ее поддерживает STM32Cube ;-). Есть куча других подобных систем &amp;ndash; та же ChibiOS. По своей сути они все одинаковые, только различаются командами и их форматом. Тут я не собираюсь переписывать гору книг и инструкций по работе с операционными системами, просто пробегусь широкими мазками по наиболее интересным вещам, которые очень сильно помогают программистам в их нелегкой работе.\n\nЛадно, буду считать что прочитали в интернете и прониклись. Смотрим, что поменялось\n\nГде-то в начале main.c\n&amp;nbsp;\n\n\nstatic void StartThread(void const * argument);\n\n\n\n\nи после всех инициализаций\n&amp;nbsp;\n\n\n/* Create Start thread */\nosThreadDef(USER_Thread, StartThread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);\nosThreadCreate (osThread(USER_Thread), NULL);\n\n/* Start scheduler */\nosKernelStart(NULL, NULL);\n\n\n\n\n\nИ пустая StartThread с одним бесконечным циклом и osDelay(1);\n\nУдивлены? А между тем перед вами практически 90% функционала, которые вы будете использовать. Первые две строки создают поток с нормальными приоритетом, а последняя строка запускает в работу планировщик задач. И все это великолепие укладывается в 6 килобайт флеша.\n\nНо нам надо проверить работу. Меняем osDelay на следующий код\n&amp;nbsp;\n\n\nHAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_RESET);\nosDelay(500);\nHAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_SET);\nosDelay(500);\n\n\n\n\nКомпилируем и заливаем. Если все сделано правильно, то у нас должен замигать синий светодиодик (на STM32F3Discovery на PE8-PE15 распаяна кучка светодиодов, поэтому если у вас другая плата, то смените код)\n\nА теперь возьмем и растиражируем полученную функцию для каждого светодиода.\n&amp;nbsp;\n\n\nstatic void PE8Thread(void const * argument);\nstatic void PE9Thread(void const * argument);\nstatic void PE10Thread(void const * argument);\nstatic void PE11Thread(void const * argument);\nstatic void PE12Thread(void const * argument);\nstatic void PE13Thread(void const * argument);\nstatic void PE14Thread(void const * argument);\nstatic void PE15Thread(void const * argument);\n\n\n\n\nДобавим поток для каждого светодиода\n\n\nosThreadDef(PE8_Thread, PE8Thread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);\nosThreadCreate (osThread(PE8_Thread), NULL);\n\n\n\n\nИ перенесем туда код для зажигания светодиода\n\n\nstatic void PE8Thread(void const * argument)\n{\nfor(;;)\n  {\n    HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_RESET);\n    osDelay(500);\n    HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_SET);\n    osDelay(500);\n  }\n}\n\n\n\n\nВ общем все однотипно.\n\nКомпилируем, заливаем &amp;hellip; и получаем фигу. Полную. Ни один светодиод не мигает.\n\nПутем страшной отладки методом комментирования выясняем, что 3 потока работают, а 4 &amp;ndash; уже нет. В чем проблема? Проблема в выделенной памяти для шедулера и стека.\n\nСмотрим в FreeRTOSConfig.h\n&amp;nbsp;\n\n\n#define configMINIMAL_STACK_SIZE ((unsigned short)128)\n#define configTOTAL_HEAP_SIZE ((size_t)3000)\n\n\n\n\n3000 байт на все и каждой задаче 128 байт. Плюс еще где-то надо хранить информацию о задаче и прочем полезном. Вот поэтому, если ничего не делать, планировщик при нехватке памяти даже не стартует.\n\nСудя по факам, если включить полную оптимизацию, то сам FreeRTOS возьмет 250 байт. Плюс на каждую задачу по 128 байт для стека, 64 для внутреннего списка и 16 для имени задачи. Считаем: 250+3*(128+64+16)=874. Даже до килобайта не дотягивает. А у нас 3 &amp;hellip;\n\nВ чем проблема? Поставляемая с STM32Cube версия FreeRTOS слишком старая (7.6.0), что бы заиметь vTaskInfo, поэтому я захожу сбоку:\n\nПеред и после создания потока я поставил следующее (fre &amp;ndash; это обычный size_t)\n&amp;nbsp;\n\n\nfre=xPortGetFreeHeapSize();\n\n\n\n\nВтыкаем брекпоинты и получаем следующие цифры: перед созданием задачи было 2376 свободных байт, а после 1768. То есть на одну задачу уходит 608 байт. Проверяем еще. Получаем цифры 2992-2376-1768-1160. Цифра совпадает. Путем простых логических умозаключений понимаем, что те цифры из фака взяты для какого-нибудь дохлого процессора, со включенными оптимизациями и выключенными всякими модулями. Смотрим дальше и понимаем, что старт шедулера отьедает еще примерно 580 байт.\n\nВ общем, принимаем для расчетов 610 байт на задачу с минимальным стеком и еще 580 байт для самой ОС. Итого в TOTAL_HEAP_SIZE надо записать 610*9+580=6070. Округлим и отдадим 6100 байт &amp;ndash; пусть жирует.\n\nКомпилируем, заливаем и наблюдаем, как мигают все светодиоды разом. Пробуем уменьшить стек до 6050 &amp;ndash; опять ничего не работает. Значит, мы подсчитали правильно :)\n\nТеперь можно побаловаться и позадавать для каждого светодиодика свои промежутки &amp;ldquo;импульса&amp;rdquo; и &amp;ldquo;паузы&amp;rdquo;. В принципе, если обновить FreeRTOS или поколдовать в коде, то легко дать точность на уровне 0,01мс (по умолчанию 1 тик &amp;ndash; 1мс).\n\nСогласитесь, работать с 8ю задачами поодиночке гораздо приятней, чем в одной с 8ю одновременно? В реальности у нас в проектах обычно крутится по 30-40 потоков. Сколько было бы смертей программистов, если всю их обработку запихать в одну функцию я даже подсчитать боюсь :)\n\nСледующим шагом нам необходимо разобраться с приоритетами. Как и в реальной жизни, некоторые задачи &amp;ldquo;равнее&amp;rdquo; остальных и им необходимо больше ресурсов. Для начала заменим одну мигалку мигалкой же, но сделанной неправильно, когда пауза делается не средствами ОС, а простым циклом.\n\nТо есть вместо osDelay() вставляется вот такой вот ужас.\n&amp;nbsp;\n\n\nunsigned long c;\nfor(int i=0;i&amp;lt;1000000;i++)\n{\n  c++;\n}\n\n\n\n\nЧисло циклов обычно подбирается экспериментально (ибо если таких задержек несколько, то куча головной боли в расчетах обеспечено). Эстеты могут подчитать время выполнения команд.\n\nЗаменяем, компилируем, запускаем. Светодиодики мигают по прежнему, но как-то вяло. Просмотр осциллографом дает понять, что вместо ровных границ (типа 50мс горим и 50мс не горим), границы стали плавать на 1-2мс (глаз, как ни странно, это замечает). Почему? Потому что FreeRTOS не система реального времени и может позволить себе такие вольности.\n\nА теперь давайте поднимем приоритет этой задаче на один шажок, до osPriorityAboveNormal. Запустим и увидим одиноко мигающий светодиод. Почему?\n\nПотому что планировщик распределяет задачи по приоритетам. Что он видит? Что задача с высоким приоритетом постоянно требует процессор. Что в результате? Остальным задачам времени на работу не остается.\n\nА теперь понизим приоритет на один шаг от нормального, до osPriorityBelowNormal. В результате планировщик, дав поработать нормальным задачам, отдает оставшиеся ресурсы &amp;laquo;плохой&amp;raquo;.\n\nОтсюда можно легко вывести первое правило программиста: если функции нечего делать, то отдай управление планировщику.\n\nВ FreeRTOS есть два варианта &amp;laquo;подожди&amp;raquo;\n\nПервый вариант &amp;laquo;просто подожди N тиков&amp;raquo;. Обычная пауза, без каких либо изысков: сколько сказали подождать, столько и ждем. Это vTaskDelay (osDelay просто синоним). Если посмотреть на время во время выполнения, то будет примерно следующее (примем что полезная задача выполняется 24мс):\n\n&amp;hellip; [0ms] &amp;mdash; передача управления &amp;mdash; работа [24ms] пауза в 100мс [124ms] &amp;mdash; передача управления &amp;mdash; работа [148ms] пауза в 100мс [248ms]&amp;hellip;\n\nЛегко увидеть, что из-за времени, требуемой на работу, передача управления происходит не каждые 100мс, как изначально можно было бы предположить. Для таких случаев есть vTaskDelayUntil. С ней временная линия будет выглядеть вот так\n\n&amp;hellip; [0ms] &amp;mdash; передача управления &amp;mdash; работа [24ms] пауза в 76мс [100ms] &amp;mdash; передача управления &amp;mdash; работа [124ms] пауза в 76мс [200ms]&amp;hellip;\n\nКак видно, задача получает управление в четко обозначенные временные промежутки, что нам и требовалось. Для проверки точности планировщика в одном из потоков я попросил делать паузы по 1мс. На картинке можете оценить точность работы с 9ю потоками (про StartThread не забываем)\n\n\n\nНа этом я обычно заканчиваю, ибо народ настолько погружается в игру с приоритетами и выяснением &amp;laquo;когда оно сломается&amp;raquo;, что проще замолчать и дать поразвлекаться.&amp;nbsp;\n\nПолностью собранный проект со всеми исходниками можно взять по адресу&amp;nbsp;kaloshin.ru/stm32/freertos/stage1.rar&amp;nbsp;\n\n&amp;nbsp;\n\n&amp;nbsp;\n\nСсылка на оригинал статьи:&amp;nbsp;https://habr.com/post/249273/\n'),
(54, 1, 1, '2018-09-14 10:30:20', 'Фильтр подавляет помеху 60 Гц.', 'Изображенная на Рисунке 1 схема очищает от помехи 60 Гц слабые низкочастотные сигналы, потребляя не более 95 мкА от единственного источника питания 5 В.', 'images/posts/2018-09-14_103020_Filyt_453.jpeg', '<p>Резисторы R1, R2, R3&nbsp;и конденсаторы C1, C2, C3&nbsp;образуют классический двойной T-мост, а микросхемы IC1&nbsp;и IC2&nbsp;обеспечивают местную и общую обратную связь. Добротность Q и характеристики подавления этого активного фильтра очень чувствительны к относительному согласованию сопротивлений резисторов и емкостей конденсаторов секции двойного T-моста. Таблица 1 демонстрирует зависимость коэффициента подавления и добротности от сопротивления резистора RQ.</p>\n\n<table align=\"center\" border=\"0\" cellpadding=\"4\" cellspacing=\"0\">\n	<tbody>\n		<tr>\n			<td><em>Таблица 1.</em></td>\n			<td><em><strong>Зависимость коэффициента подавления<br />\n			фильтра на частоте 60 Гц и добротности<br />\n			от сопротивления резистора RQ</strong></em>.</td>\n		</tr>\n		<tr>\n			<td colspan=\"2\">\n			<table align=\"center\" border=\"1\" cellpadding=\"3\" cellspacing=\"0\">\n				<tbody>\n					<tr>\n						<td><strong>Q фильтра</strong></td>\n						<td><strong>RQ<br />\n						(кОм)</strong></td>\n						<td><strong>Подавление<br />\n						(дБ)</strong></td>\n						<td><strong>VOUT/VIN</strong></td>\n					</tr>\n					<tr>\n						<td>0.75</td>\n						<td>1</td>\n						<td>40</td>\n						<td>1.33</td>\n					</tr>\n					<tr>\n						<td>1.25</td>\n						<td>2</td>\n						<td>35</td>\n						<td>1.5</td>\n					</tr>\n					<tr>\n						<td>2.5</td>\n						<td>3</td>\n						<td>30</td>\n						<td>1.6</td>\n					</tr>\n					<tr>\n						<td>2.5</td>\n						<td>8</td>\n						<td>25</td>\n						<td>1.8</td>\n					</tr>\n					<tr>\n						<td>5</td>\n						<td>18</td>\n						<td>20</td>\n						<td>1.9</td>\n					</tr>\n					<tr>\n						<td>10</td>\n						<td>38</td>\n						<td>15</td>\n						<td>1.95</td>\n					</tr>\n				</tbody>\n			</table>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>R4, R5, C4&nbsp;и IC3&nbsp;образуют низкоимпедансный опорный источник, смещающий IC1&nbsp;и секции двойного T-моста на половину напряжения питания.</p>\n\n<p>Чтобы настроить фильтр на 60 Гц, выберите такое значение Q, которое обеспечит достаточное ослабление без чрезмерных потерь полезных низкочастотных сигналов, частоты которых могут располагаться вблизи частоты подавления фильтра. Сопротивление RQвычисляется как</p>\n\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2017/07/19/F_1.gif\" /></p>\n\n<p>Коэффициент усиления выходного каскада рассчитывается как для обычного неинвертирующего усилителя:</p>\n\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2017/07/19/F_2.gif\" /></p>\n\n<p>а общее усиление полосового режекторного фильтра выше и ниже частоты подавления выражается как</p>\n\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2017/07/19/F_3.gif\" /></p>\n\n<p>Если потребуется дополнительное подавление, секции фильтра можно каскадировать. Имейте в виду, что при этом, возможно, вам придется видоизменить схему, чтобы учесть внеполосное усиление.</p>\n\n<h2>Материалы по теме</h2>\n\n<ol>\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=335109&amp;/OP490\">Datasheet Analog Devices OP490</a></li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><em>Перевод: AlexAAN по заказу&nbsp;<a href=\"https://www.rlocman.ru/\" target=\"_blank\">РадиоЛоцман</a></em></p>\n\n<p>На английском языке:&nbsp;<a href=\"https://www.radiolocman.com/shem/schematics.html?di=337441\" target=\"_blank\">Filter quashes 60-Hz interference</a></p>\n'),
(55, 1, 3, '2018-09-14 11:48:45', 'Генератор с независимой регулировкой ширины и частоты биполярных импульсов', 'Биполярные импульсы преимущественно используют для поочередного переключения транзисторов в мостовых и полумостовых преобразователях напряжения. Хорошо известно, что при работе таких преобразователей на повышенных частотах на надежности их работы начинают фатально сказываться инерционные процессы рассасывания неосновных носителей тока в базовых цепях силовых транзисторов. В итоге последовательно включенные транзисторы могут одновременно оказаться в токопроводящем состоянии, несмотря на отсутствие управляющего сигнала. В этой связи с высокой долей вероятности возможен выход из строя дорогостоящих транзисторов за счет протекания через них неконтролируемого сквозного тока.', 'images/posts/2018-09-14_114845_Gener_571.jpeg', '<p>Для того чтобы снизить вероятность протекания сквозного тока между импульсами вводят паузу, длительность которой должна несколько превышать время рассасывания неосновных носителей тока.</p>\n\n<p>Способ получения серии биполярных импульсов из последовательности однополярных с использованием генератора импульсов, D-триггера, схем антисовпадений и операционного усилителя, питаемого от источника двуполярного напряжения, был впервые описан в британской печати [4] и затем продублирован в отечественной [5].</p>\n\n<p>Устройство (Рисунок 1) наследует выходные каскады формирователей [4, 5] и отличается возможностью плавного и независимого регулирования частоты и ширины биполярных импульсов.</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2018/08/26/F_1.gif\" style=\"height:80%; width:80%\" />Задающий генератор выполнен на элементе DD1.1 КМОП микросхемы CD40106. Рабочая частота генератора определяется RC-цепями: емкостью конденсатора С1 и суммарным сопротивлением резисторов и потенциометров R1&ndash;R5. Эту частоту можно плавно регулировать при помощи потенциометра R2 в пределах от 850 до 6000 Гц. Частоту работы генератора можно рассчитать по выражению</p>\n\n<p>где</p>\n\n<p>f &ndash; в кГц,<br />\nR &ndash; в кОм,<br />\nС &ndash; в мкФ.</p>\n\n<p>Резистивная цепочка R3&ndash;R5 подключена параллельно цепочке R1, R2. С движка потенциометра этой цепочки R4 снимается сигнал пилообразной формы, формируемый при заряде-разряде конденсатора С1. Этот сигнал, инвертированный элементом DD1.2 (триггер Шмитта, обладающий пороговым эффектом переключения), совместно с сигналом, снимаемым с выхода задающего генератора, поступает на элемент DD2.1 &laquo;ИЛИ&raquo; и на формирователь биполярных импульсов (элементы DD2.2, DD2.3, микросхема DA1), выполненный по ранее известной схеме [4, 5].</p>\n\n<p>Регулировка потенциометра R4 позволяет в широких пределах, практически от 0 до 100%, менять ширину выходных биполярных импульсов, не влияя на частоту работы генератора. Резисторы R3, R5 предназначены для ограничения пределов регулировки ширины импульсов по минимуму и по максимуму их длительности.</p>\n\n<h2>Литература</h2>\n\n<ol>\n	<li><a id=\"1\" name=\"1\"></a>Шустов М.А. Практическая схемотехника. Преобразователи напряжения. &ndash; М.: Altex-A, 2002. &ndash; Кн. 3. &ndash; 184 с.; М.: Додэка-XXI&ndash;Altex, 2007. &ndash; 192 с. (II изд.).</li>\n	<li>&nbsp;<a id=\"2\" name=\"2\"></a>Шустов М.А. Основы силовой электроники. &ndash; СПб.: Наука и Техника, 2017. &ndash; 336 с.</li>\n	<li><a id=\"3\" name=\"3\"></a>Shustov M.A., Shustov A.M. Electronic Circuits for All. &ndash; London: Elektor International Media BV, 2017. &ndash; 397 p.</li>\n	<li><a id=\"4\" name=\"4\"></a>Rauniar K.N. Unipolar-to-bipolar pulse converter // Electronics World + Wireless World. &ndash; 1989. &ndash; № 11. &ndash; P. 1098.</li>\n	<li><a id=\"5\" name=\"5\"></a>Васильев В. Задающий генератор преобразователя напряжения // Радио. &ndash; 2006. &ndash; № 10. &ndash; С. 47.</li>\n</ol>\n\n<h2>Материалы по теме</h2>\n\n<ol>\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=450065&amp;/CA3140\">Datasheet Intersil CA3140</a></li>\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=285915&amp;/CD4001B\">Datasheet Texas Instruments CD4001B</a></li>\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=285981&amp;/CD40106B\">Datasheet Texas Instruments CD40106B</a></li>\n</ol>\n');

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE `users` (
  `id` int(10) UNSIGNED NOT NULL,
  `usermail` varchar(30) DEFAULT NULL,
  `password` varchar(40) DEFAULT NULL,
  `screen_name` varchar(30) DEFAULT NULL,
  `creation_date` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `users`
--

INSERT INTO `users` (`id`, `usermail`, `password`, `screen_name`, `creation_date`) VALUES
(1, 'adm@mail.ru', '111', 'adm', '2018-09-10 17:40:18'),
(7, 'adm1@mail.ru', '111', 'adm', '2018-09-13 09:19:40'),
(8, 'Vasya7@gmail.com', '1111', 'Vas7', '2018-09-13 09:54:03'),
(9, 'Vasya5@gmail.com', '1111', 'Vas5', '2018-09-13 10:47:26');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `category`
--
ALTER TABLE `category`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `posts`
--
ALTER TABLE `posts`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `category`
--
ALTER TABLE `category`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- AUTO_INCREMENT для таблицы `posts`
--
ALTER TABLE `posts`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=56;

--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=10;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
